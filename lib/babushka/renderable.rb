module Babushka
  class Renderable
    include ShellHelpers
    include RunHelpers

    SEAL_REGEXP = /# Generated by babushka-[\d\.]+ at [a-zA-Z\d\-\:\s+]+, from [0-9a-f]{40}+\. [0-9a-f]{40}/

    attr_reader :path
    def initialize path
      @path = path
    end

    def render source, opts = {}
      shell("cat > '#{path}'",
        :input => inkan_output_for(source, opts),
        :sudo => opts[:sudo]
      ).tap {|result|
        if result
          sudo "chmod #{opts[:perms]} '#{path}'" if opts[:perms]
        end
      }
    end

    def exists?
      path.p.exists?
    end

    def clean?
      Inkan.legitimate? path
    end

    def from? source
      exists? && source_sha == sha_of(source)
    end

    private

    def inkan_output_for source, opts = {}
      Inkan.render {|inkan|
        inkan.credit = "Generated #{_by_babushka}, from #{sha_of(source)}"
        inkan.comment = opts[:comment] if opts[:comment]
        inkan.comment_suffix = opts[:comment_suffix] if opts[:comment_suffix]
        inkan.print render_erb(source, opts[:context])
      }
    end

    def render_erb source, custom_context
      require 'erb'
      (custom_context || self).instance_eval {
        ERB.new(source.p.read).result(binding)
      }
    end

    def sha_of source
      require 'digest/sha1'
      raise "Source doesn't exist: #{source.p}" unless source.p.exists?
      Digest::SHA1.hexdigest(source.p.read)
    end

    def source_sha
      unless File.readable?(path.p)
        lines = sudo("head -2 #{path.p}").lines.to_a
        # if first line starts with a hash bang return second line
        if lines.count > 1 && lines[0][/\A#!/]
          lines[1]
        else
          lines.count > 0 ? lines[0] : ''
        end
      else
        File.open(path.p) {|f|
          first_line = f.gets
          first_line[/\A#!/] ? f.gets : first_line
        }
      end.scan(/, from ([0-9a-f]{40})\./).flatten.first
    end
  end
end

